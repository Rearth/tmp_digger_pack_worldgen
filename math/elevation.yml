vars: &variables
  height: $meta.yml:continentalHeight
  heightVariation: 25
  elevationFactorOffset: 0.5
  baseHeight: $meta.yml:baseY

  #  refuge config
  refugeBase: ${meta.yml:baseY} + 5
  refugeHeight: 50
  pillarHeight: 50
  pillarCutoff: 0.95
  pillarFlatness: 1.7
  pillarVariation: 0.03
  bendFactor: 0.8

  # loop config
  archHeight: 3.5
  archRadius: 35
  archAngle: 1.2
  archBase: ${meta.yml:baseY} -5
  archSize: 50

helpers: &helpers
  terrace:
    arguments: [x, terraceStrength]
    expression: round(x) + 0.5 * (2*(x - round(x)))^terraceStrength
  lerp:
    # Linear interpolation between two values
    arguments:
      - t
      - at # Value of t where output = a
      - a
      - bt # Value of t where output = b
      - b
      # Values of t between at and bt will be interpolated
    expression: |
      if(at<bt,
        if(t<=at,a,if(t>=bt,b,a*(t-bt)/(at-bt)+b*(t-at)/(bt-at))),
        if(t>=at,a,if(t<=bt,b,a*(t-bt)/(at-bt)+b*(t-at)/(bt-at)))
      )
  clamp:
    arguments: [x, a, b] # clamps x between a (low) and b (high)
    expression: min(max(x, a), b)

samplers:
  
  # basic, raw continental height. Is usually higher towards the cell center, and amplified per continent based on 'continentElevationFactor'
  # return a range between 0-continentalHeight, and the elevationFactor is already included
  continentalElevation: &continentalElevation
    dimensions: 2
    type: EXPRESSION
    variables: *variables
    expression: |
      min(max(cellHeights(x,z) + elevationFactorOffset, 0.2), 1)
      * sigmoid((cellDist(x,z) + 1), 0.5, 8) * height
    functions:
      sigmoid:
        arguments: [x, center, scale]
        expression: 1 / (1+2.71828^-((x-center) * scale))
    samplers:
      cellHeights:  &cellHeights
        dimensions: 2
        type: "CELLULAR"
        return: "CellValue"
        frequency: 1 / ${meta.yml:continentSize}
      cellDist:
        type: DOMAIN_WARP
        amplitude: 20
        dimensions: 2
        warp:
          type: FBM
          octaves: 3
          sampler:
            type: OPEN_SIMPLEX_2
            frequency: 1 / ${meta.yml:continentSize}
        sampler:
          type: "CELLULAR"
          frequency: 1 / ${meta.yml:continentSize}
          distance: Euclidean
          return: Distance2Sub

  # to allow caves to actually penetrate the surface in some places
  caveElevationMask:
    dimensions: 2
    type: EXPRESSION
    variables: *variables
    expression: |
      base(x,z) + abs(offset(x,z) * 15)
    samplers:
      base: *continentalElevation
      offset:
        dimensions: 2
        type: OPEN_SIMPLEX_2S
        frequency: 1 / 300 * 2


  # returns a value between 0.2 and 1, describing the maximum height of a continental plate (e.g. is the continent flat or mountainy)
  continentElevationFactor: &continentElevationFactor
    dimensions: 2
    type: EXPRESSION
    variables: *variables
    expression: |
      min(max(cellHeights(x,z) + elevationFactorOffset, 0.2), 1)
    samplers:
      cellHeights: *cellHeights

  mediumDetail: &mediumDetail
    dimensions: 3
    type: EXPRESSION
    variables: *variables
    expression: |
      continent(x ,z)
      + (mountains(x, y, z) - 0.1) * heightVariation * max(heightFactor(x,z), 0.5) * 1.4
    samplers:
      continent: *continentalElevation
      heightFactor: *continentElevationFactor
      mountains:
        dimensions: 3
        type: DOMAIN_WARP
        warp:  
          type: FBM
          octaves: 3
          gain: 0.7
          lacunarity: 2.4
          sampler:
            type: OPEN_SIMPLEX_2S
            frequency: 1 / 300 * 1
        amplitude: 150
        sampler:
          dimensions: 2
          type: EXPRESSION
          expression: |
            (cellHeight3(x,z) + 1) / 1.5
          samplers:
            cellHeight3:
              dimensions: 2
              type: CELLULAR
              return: Distance2Sub
              frequency: 1 / 300 * 2
              seed: 1
  
  # -1 to -0.85 = refuge, 0 - 0.3 = mesa, 0.8 - 1 = loops
  globalFeature: &globalFeature
    dimensions: 2
    type: CELLULAR
    return: CellValue
    frequency: 1 / 400

  globalEq:
    dimensions: 3
    type: EXPRESSION
    variables: *variables
    expression: |
      // flat plane
      -y + baseHeight

      // base shape, with some terracing. Only executed above y > baseHeight - 10 for performance reasons
      + if(y > baseHeight - 10,
          if (warpedFeature(x * 2, z * 2) < -0.3 || continent(x,z) < 30,
            mediumDetail(x,y,z), 
            terrace(mediumDetail(x,y,z) / (20 + extraRandom(x,z) * 3), 13) * (20 + extraRandom(x,z) * 3)
          ),
          0
        )

      // optional features
      + cellFeatures(x,y,z)
    functions: *helpers
    samplers:
      continent: *continentalElevation
      mediumDetail: *mediumDetail
      warpedFeature:
        type: DOMAIN_WARP
        dimensions: 2
        sampler:
          type: CELLULAR
          return: CellValue
          frequency: 1 / ${meta.yml:continentSize} * 3
        warp:
          type: OPEN_SIMPLEX_2
          frequency: 1 / ${meta.yml:continentSize} * 3
        amplitude: 40
      simpleFeature:
        dimensions: 2
        type: CELLULAR
        return: CellValue
        frequency: 1 / ${meta.yml:continentSize} * 3
      extraRandom:
        type: OPEN_SIMPLEX_2S
        dimensions: 2
        frequency: 1 / ${meta.yml:continentSize} * 3
      cellFeatures:
        type: EXPRESSION
        dimensions: 3
        expression: |
          // other features: mesa pillars (done as actual feature), pillowy pillar
          if(continent(x,z) > 40, 
            0,
            worldCaves(x,y,z)
          )

          + if (globalFeature(x, z) > 0.8, worldLoops(x,y,z), 0)
        functions: *helpers
        samplers:
          continent: *continentalElevation
          globalFeature: *globalFeature
          worldCaves:
            dimensions: 3
            type: EXPRESSION
            variables: *variables
            expression: |
              if (y > refugeBase - 15 && y < refugeBase + refugeHeight * 1.3, 
                max(pillars(x + yCurve(y, 0), y, z + yCurve(y, 0)), 
                  max(pillars(x - yCurve(y, 0), y, z + yCurve(y, 0)), pillars(x - yCurve(y, 0) + 5000, y, z - yCurve(y, 0)))),
              0)
            functions:
              terrace:
                arguments: [x, terraceStrength]
                expression: round(x) + 0.5 * (2*(x - round(x)))^terraceStrength
            samplers:
              yCurve:
                dimensions: 2
                type: EXPRESSION
                variables: *variables
                expression: |
                  curve(1 - normalizeY(x, refugeBase, pillarHeight)) * pillarHeight * bendFactor
                functions:
                  normalizeY:
                    arguments: [y, refugeBase, refugeHeight]
                    expression: (y - refugeBase) / refugeHeight
                  curve:
                    arguments: [x]
                    expression: if (x < 0.1, 0.35, 2.428571*x - 1.428571*x^2)
              pillars:
                dimensions: 3
                type: EXPRESSION
                variables: *variables
                functions: *helpers
                expression: |
                  if(pillarRand(x,z) > 0.1 && pillarGlobalFilter(x,z) < -0.85,
                  clamp(
                    (-pillars(x,z) 
                      - pillarCutoff 
                      - widthVariation(y, x / 4 + z / 3) * pillarVariation 
                      + (y - refugeBase) / pillarHeight / 8
                      + max(refugeBase - y + 4, 0) / 200
                      - (1 - abs(refugeBase + pillarHeight - y + 25) / pillarHeight)^5
                      // + (min(0, refugeBase + pillarHeight - y + 6))^3
                      - max(-abs(erosion(x,y,z)) + 0.3, 0) * 0.095
                      )
                      * pillarHeight
                      * (1 / (1 - pillarCutoff)) * pillarFlatness,
                    -2, pillarHeight * 1.2), 0)
                samplers:
                  pillars: &pillars
                    dimensions: 2
                    type: CELLULAR
                    frequency: 0.009
                  erosion:
                    dimensions: 3
                    type: OPEN_SIMPLEX_2S
                    frequency: 0.06
                  widthVariation:
                    dimensions: 2
                    type: FBM
                    sampler:
                      type: OPEN_SIMPLEX_2S
                      frequency: 0.05
                    octaves: 2
                    lacunarity: 2
                    gain: 0.5
                  pillarRand:
                    <<: *pillars
                    return: CellValue
                  pillarGlobalFilter:
                    <<: *pillars
                    return: NoiseLookup
                    lookup: *globalFeature

          worldLoops:
            dimensions: 3
            type: EXPRESSION
            variables: *variables
            expression: |
              // positive / higher = solid
              if(y > archBase - 5 && y < archBase + archSize + 30,
                max(arches(rotate(x, z, archAngle), y - 21, rotate(z, x, archAngle)) * 70, -1),
                0
              )
            functions:
              rotate:
                arguments: [x, y, rad]
                expression: x * cos(rad) - y * sin(rad)
            samplers:
              arches:
                dimensions: 3
                type: EXPRESSION
                variables: *variables
                expression: |
                  // positive / higher = solid
                  (-abs((archBase + archSize * (pillarRand(0, z) * 0.3 + 1) * wave(x * 1.3 + pillarRand(0, z) * 50, archRadius)) - y) + archHeight) / archHeight // wave along x-axis
                  - (archMask(z, 0) + 0.98) * 190 * (pillarRand(0, z) * 0.4 + 1) // transform it along x-axis to transform the wave into arches
                  + widthRandom(x,y,z) * 0.8
                functions:
                  wave:
                    arguments: [x, frequency]
                    expression: -sin(x / frequency)
                  smoothAbs:
                    arguments: [x]
                    expression: sqrt(x * x)
                samplers:
                  widthRandom:
                    dimensions: 3
                    type: OPEN_SIMPLEX_2
                    frequency: 0.05
                  pillarRand:
                    dimensions: 2
                    type: CELLULAR
                    frequency: 0.012
                    jitter: 0.2
                    return: CellValue
                  archMask: # 1-dimensional
                    dimensions: 2
                    type: LINEAR
                    min: -1
                    max: 0.2
                    sampler:
                      type: CELLULAR
                      frequency: 0.012
                      jitter: 0.2
